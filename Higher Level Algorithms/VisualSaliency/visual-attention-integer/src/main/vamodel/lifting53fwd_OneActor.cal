package main.vamodel;

import std.header.Parameter.*;
import std.header.Source.*;

actor lifting53fwd_OneActor() uint(size=8) imageStream ==> int coefficient: 
	int  imageBuffer[IM_WIDTH][IM_HEIGHT];	
	uint(size=32) countX := 0;
	uint(size=32) countY := 0;	
	
	getImageValue: action imageStream:[Bytes] ==>  	
	do		
		imageBuffer[countX][countY] := Bytes;
		countY := countY + 1;
		
		if(countY = IM_HEIGHT) then
			countX := countX + 1;
			countY := 0; 
		end									
	end
	
	doneCountX: action ==>
	guard countX = IM_WIDTH
	do
		countX := 0;		
	end

	
	int width := IM_WIDTH;
	int height := IM_HEIGHT;
		
	waveletTransform: action ==>	
	var int tempBank[IM_WIDTH][IM_HEIGHT]	
	do	
		//println("DWT");
		foreach int d_level in 0 .. (LEVEL-1) do
			foreach int x in 0 .. (width-1) do
            	// Prediction 
            	foreach int y in 0 .. (height/2-1) do            		 
            		imageBuffer[x][2*y+1] := imageBuffer[x][2*y+1] -  ((imageBuffer[x][2*y+1-1] + imageBuffer[x][2*y+1+1]) >> 1);              	                
            	end
            	            	
            	imageBuffer[x][height-1] := imageBuffer[x][height-1] - imageBuffer[x][height-2] ;// Symmetric extension
            
            	// Update 
            	foreach int y in 1 .. (height/2-1) do                
                	imageBuffer[x][2*y] := imageBuffer[x][2*y] + ((imageBuffer[x][2*y-1] + imageBuffer[x][2*y+1]) >> 2);                         
            	end            	
            	imageBuffer[x][0] := imageBuffer[x][0] + (imageBuffer[x][1] >> 1); // Symmetric extension                   
        	end
        	
        	// De-interleave		
        	foreach int x in 0 .. (width-1) do
            	foreach int y in 0 .. (height-1) do                
                	// simultaneously transpose the matrix when deinterleaving
                	if((y mod 2) = 0) then //Odd
                    	tempBank[x][y/2] := imageBuffer[x][y];
                	else //even
	                    tempBank[x][y/2 + height/2] := imageBuffer[x][y];
    	            end
        	    end
        	end
                	
            foreach int x in 0 .. (width-1) do
            	foreach int y in 0 .. (height-1) do
                	imageBuffer[x][y] := tempBank[x][y];
            	end
        	end
        	
        	//Row
        	foreach int x in 0 .. (height-1) do
            	// Prediction 1
            	foreach int y in 0 .. (width/2-1) do
                	imageBuffer[2*y+1][x] := imageBuffer[2*y+1][x] - ((imageBuffer[2*y+1-1][x] + imageBuffer[2*y+1+1][x])>>1);
            	end
            	imageBuffer[width-1][x] := imageBuffer[width-1][x] - imageBuffer[width-2][x] ;// Symmetric extension
            	
	            // Update 1
    	        foreach int y in 1 .. (width/2-1) do
        	        imageBuffer[2*y][x] := imageBuffer[2*y][x] + ((imageBuffer[2*y-1][x] + imageBuffer[2*y+1][x]) >> 2);
            	end
            	imageBuffer[0][x] := imageBuffer[0][x] + (imageBuffer[1][x] >> 1); // Symmetric extension                   
        	end    	
  
        	// De-interleave      
        	foreach int x in 0 .. (width-1) do
            	foreach int y in 0 .. (height-1) do
                	// simultaneously transpose the matrix when deinterleaving
                	if((x mod 2) = 0) then //Even
                    	tempBank[x/2][y] := imageBuffer[x][y];
                	else  //Odd
                    	tempBank[x/2 + width/2][y] := imageBuffer[x][y];
                	end
            	end
        	end

        	foreach int x in 0 .. (width-1) do
            	foreach int y in 0 .. (height-1) do
                	imageBuffer[x][y] := tempBank[x][y];
            	end
        	end
        	
        	// --- Adjust width and height for next level decomposition
			width := width/2;
            height := height/2;
		end
	end
	

	sendCoefficient: action ==> coefficient:[coeff]
	var int coeff
	do
		coeff := imageBuffer[countX][countY];		
		countY := countY + 1;		
		if(countY = IM_HEIGHT) then
			countX := countX + 1;
			countY := 0; 			
		end
	end
	
	block: action ==>
		guard false
	end	
	
	schedule fsm s0 :			
		s0 (getImageValue ) --> s0;
		s0 (doneCountX ) --> s1;
		s1 (waveletTransform) --> s2; 
		s2 (sendCoefficient) --> s2;
		s2 (doneCountX) --> s3;
		s3 (block) --> s3;			
	end
	
	priority
		doneCountX > getImageValue;
		doneCountX > sendCoefficient;		
	end

end